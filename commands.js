/**
 * commands.js
 *
 * Defines the bot’s command registry.
 *
 * Flow:
 *   bot.js parses a message into { cmd, rest } and calls:
 *     registry.get(cmd)?.({ message, cmd, rest })
 *
 * Adding a new command:
 *   1) Register it:
 *        register("!mycmd", async ({ message, rest }) => { ... }, "!mycmd — help text");
 *   2) Parse `rest` (trim / split on /\s+/) and validate inputs.
 *   3) Reply with `message.reply(...)` or `message.channel.send(...)`.
 *
 * Notes:
 *   - Unknown commands are ignored.
 *   - Admin-only commands: pass { admin: true } and enforce permission in handler.
 *   - `!help` is autogenerated from registry help strings and hides admin commands.
 */

import fs from "node:fs";
import path from "node:path";
import { createFaqService } from "./faq.js";
import { createWikiService } from "./wiki.js";
import { registerCalculator } from "./calculator.js";
import { registerContests } from "./contests.js";
import { registerTrades } from "./trades.js";
import { registerRarity } from "./rarity.js";

// Small helpers used by multiple commands
function randIntInclusive(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

function targetUserId(message) {
  // If someone is mentioned, use the first mention; else author.
  const first = message.mentions?.users?.first?.();
  return first?.id ?? message.author.id;
}

function mention(id) {
  return `<@${id}>`;
}

function canReload(message) {
  if (!message.member) return false;
  return (
    message.member.permissions?.has("Administrator") ||
    message.member.permissions?.has("ManageGuild")
  );
}

// Channel allowlist for specific commands
// guildId -> array of allowed channelIds
const AWESOME_CHANNELS = {
  "329934860388925442": ["331114564966154240", "551243336187510784"]
};
const TRADING_GUILD_ALLOWLIST = (process.env.TRADING_GUILD_ALLOWLIST || "")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean);
const RARITY_GUILD_ALLOWLIST = (process.env.RARITY_GUILD_ALLOWLIST || "")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean);

const TRADING_ENABLED_ANYWHERE = TRADING_GUILD_ALLOWLIST.length > 0;
const RARITY_ENABLED_ANYWHERE = RARITY_GUILD_ALLOWLIST.length > 0;


function isAllowedChannel(message, allowlist) {
  if (!message.guild) return true; // DMs allowed by default

  const guildId = message.guild.id;
  const allowedChannels = allowlist[guildId];

  // No restriction for this guild
  if (!Array.isArray(allowedChannels)) return true;

  return allowedChannels.includes(message.channel.id);
}

// Load NG list ONCE (do not reload per command)
function loadNgsOnce() {
  const filePath = path.join(process.cwd(), "data", "ngs.json");
  const raw = fs.readFileSync(filePath, "utf8");
  const data = JSON.parse(raw);

  // Allow either ["A","B"] or {"ngs":["A","B"]}
  const ngs = Array.isArray(data) ? data : Array.isArray(data?.ngs) ? data.ngs : null;
  if (!ngs) throw new Error("data/ngs.json must be an array of strings, or { ngs: [...] }");

  return ngs
    .filter((x) => typeof x === "string")
    .map((x) => x.trim())
    .filter(Boolean);
}

// Load Glossary ONCE (do not reload per command)
function loadGlossaryOnce() {
  const filePath = path.join(process.cwd(), "data", "glossary.json");
  const raw = fs.readFileSync(filePath, "utf8");
  const data = JSON.parse(raw);

  if (!data || typeof data !== "object" || Array.isArray(data)) {
    throw new Error("data/glossary.json must be an object map: { \"key\": \"definition\", ... }");
  }

  // Normalize keys to lowercase trimmed strings
  const map = {};
  for (const [k, v] of Object.entries(data)) {
    if (typeof k !== "string" || typeof v !== "string") continue;
    const kk = k.trim().toLowerCase();
    if (!kk) continue;
    map[kk] = v;
  }
  return map;
}

function parseSecondsToMs(raw) {
  const s = (raw ?? "").trim().toLowerCase();

  // Only allow whole seconds: 1s .. 30s
  const m = /^(\d+)\s*s$/.exec(s);
  if (!m) return { error: "Delay must be specified in seconds, e.g. `2s` (1s–30s)." };

  const seconds = Number(m[1]);
  if (!Number.isInteger(seconds)) {
    return { error: "Delay must be a whole number of seconds." };
  }

  if (seconds < 1) {
    return { error: "Delay must be at least 1 second." };
  }

  if (seconds > 30) {
    return { error: "Delay cannot exceed 30 seconds." };
  }

  return { ms: seconds * 1000, seconds };
}

export function buildCommandRegistry() {
  const registry = new Map();

  // Services (FAQ engine etc.)
  const faq = createFaqService();
  const wiki = createWikiService();
  registerCalculator(register);
  registerContests(register);
  if (TRADING_ENABLED_ANYWHERE) {
    registerTrades(register);
  }
  if (RARITY_ENABLED_ANYWHERE) {
    registerRarity(register);
  }

  // Load NGs once at startup
  const ngs = loadNgsOnce();

  // Load Glossary once at startup
  const glossary = loadGlossaryOnce();


  // Config
  const MAX_ROLL_N = Number(process.env.MAX_ROLL_N ?? 50);
  const MAX_ROLL_M = Number(process.env.MAX_ROLL_M ?? 100000);

  // Helper to register commands
  function register(name, handler, help = "", opts = {}) {
    const entry = {
      handler,
      help,
      admin: Boolean(opts.admin),
      canonical: true
    };

    registry.set(name.toLowerCase(), entry);

    // Register aliases (if any)
    if (Array.isArray(opts.aliases)) {
      for (const alias of opts.aliases) {
        registry.set(alias.toLowerCase(), {
          ...entry,
          canonical: false
        });
      }
    }
  }

  /* ------------------------------ Commands ------------------------------ */

  register("?roll", async ({ message, rest }) => {
    const arg = rest.trim();
    const m = /^(\d+)d(\d+)$/.exec(arg);
    if (!m) {
      await message.channel.send("Invalid format. Please use a format like `1d100`");
      return;
    }

    const n = Number(m[1]);
    const sides = Number(m[2]);

    if (!Number.isInteger(n) || !Number.isInteger(sides) || n < 1 || sides < 0) {
      await message.channel.send("Invalid format. Please use a format like `1d100`");
      return;
    }

    if (n > MAX_ROLL_N) {
      await message.channel.send(`Too many rolls. Max is ${MAX_ROLL_N}.`);
      return;
    }
    if (sides > MAX_ROLL_M) {
      await message.channel.send(`Range too large. Max m is ${MAX_ROLL_M}.`);
      return;
    }

    const uid = targetUserId(message);
    const rolls = Array.from({ length: n }, () => randIntInclusive(0, sides));
    await message.channel.send(`${mention(uid)} ${rolls.join(", ")}`);
  }, "?roll NdM — rolls N numbers from 0..M (example: !roll 1d100)");

  register("?choose", async ({ message, rest }) => {
    const options = rest.trim().split(/\s+/).filter(Boolean);
    if (options.length < 1) {
      await message.channel.send("Usage: `!choose option1 option2 ...`");
      return;
    }
    const pick = options[randIntInclusive(0, options.length - 1)];
    await message.channel.send(pick);
  }, "?choose a b c — randomly chooses one option");

  register(
    "?elim",
    async ({ message, rest }) => {
      if (!message.guild) return;

      const parts = rest.trim().split(/\s+/).filter(Boolean);

      if (parts.length < 3) {
        await message.reply("Usage: `?elim <seconds>s <item1> <item2> [...]`");
        return;
      }

      const delayRaw = parts[0];
      const parsed = parseSecondsToMs(delayRaw);

      if (parsed.error) {
        await message.reply(parsed.error);
        return;
      }

      const delayMs = parsed.ms;
      const delaySec = parsed.seconds;

      let remaining = parts.slice(1);
      if (remaining.length < 2) {
        await message.reply("You need at least 2 items to run an elimination.");
        return;
      }

      await message.channel.send(
        `Setting up elimination with ${delaySec}s between rounds... are you ready?`
      );

      remaining = [...remaining];

      const runRound = async () => {
        if (!message.channel) return;

        if (remaining.length === 1) {
          await message.channel.send(`${remaining[0]} wins!`);
          return;
        }

        const idx = Math.floor(Math.random() * remaining.length);
        const eliminated = remaining.splice(idx, 1)[0];

        await message.channel.send(
          `${eliminated} has been eliminated! Remaining: ${remaining.join(", ")}`
        );

        setTimeout(runRound, delayMs);
      };

      setTimeout(runRound, delayMs);
    },
    "?elim <1–30s> <items...> — randomly eliminates one item per round"
  );

  register("!awesome", async ({ message }) => {
    if (!isAllowedChannel(message, AWESOME_CHANNELS)) {
      return;
    }

    const uid = targetUserId(message);
    const x = randIntInclusive(0, 101);
    await message.channel.send(`${mention(uid)} is ${x}% awesome!`);
  }, "!awesome — tells you how awesome someone is (0–101%)");

  register("!faq", async ({ message, rest }) => {
    const qRaw = rest.trim();

    if (!qRaw) {
      await message.reply(
        "Please ask a specific question, like: `!faq how do I goldenize?`\n" +
        "You can also browse helpful FAQs here: https://forums.tppc.info/showthread.php?p=11516674#post11516674"
      );
      return;
    }

    const out = faq.matchAndRender({ message, questionRaw: qRaw });
    if (!out) return; // no output if no confident match
    await message.reply(out);
  }, "!faq <question> — asks the FAQ bot");

  register(
    "!faqreload",
    async ({ message }) => {
      if (!canReload(message)) {
        await message.reply(
          "Nope — you don’t have permission to run that. (Admin/Manage Server only)"
        );
        return;
      }

      try {
        const info = faq.reload();
        await message.reply(
          `Reloaded faq.json ✅ (${info.count} entries${
            info.version ? `, v${info.version}` : ""
          })`
        );
      } catch (e) {
        console.error("faq reload failed:", e);
        await message.reply("Reload failed ❌ (check console + faq.json formatting)");
      }
    },
    "!faqreload — reloads faq.json",
    { admin: true }
  );

  register("!help", async ({ message }) => {
    const isAdmin =
      message.member?.permissions?.has("Administrator") ||
      message.member?.permissions?.has("ManageGuild");

    const lines = [];

    for (const { help, admin, canonical } of registry.values()) {
      if (!canonical) continue; // hide aliases
      if (!help) continue;
      if (admin) continue; // hide admin commands
      lines.push(help);
    }

    if (lines.length === 0) return;

    await message.reply(
      "**Available commands:**\n" +
      lines.sort().map(l => `• ${l}`).join("\n")
    );
  }, "!help — shows this help message");

  // Local-title-based wiki lookup (Cloudflare-proof)
  register("!wiki", async ({ message, rest }) => {
    const q = rest.trim();
    if (!q) return; // no output

    const results = wiki.search(q);
    if (results.length === 0) return; // no output if no match

    const lines = results.map(r => `• [${r.title}](${r.url})`);
    await message.reply(lines.join("\n"));
  }, "!wiki <term> — links matching TPPC wiki pages", { aliases: ["!w"] });

  // !ng — read from data/ngs.json (loaded once)
  register(
    "!ng",
    async ({ message }) => {
      if (ngs.length === 0) return;

      const maxShow = 5;
      const shown = ngs.slice(0, maxShow);
      const extra = ngs.length - shown.length;

      const body =
        shown.map(x => `• ${x}`).join("\n") +
        (extra > 0 ? `\n…and ${extra} more.` : "");

      await message.reply(`**Current NGs:**\n${body}`);
    },
    "!ng — shows the current NG list",
    { aliases: ["!ngs"] }
  );

  // !rig — bless a user
  register("!rig", async ({ message }) => {
    const uid = targetUserId(message);
    await message.channel.send(`${mention(uid)} has now been blessed by rngesus.`);
    }, "!rig — bless someone with RNG"
  );

  // !coinflip — heads/tails
  register("!coinflip", async ({ message }) => {
    const uid = targetUserId(message);
    const result = Math.random() < 0.5 ? "Heads" : "Tails";
    await message.channel.send(`${mention(uid)} ${result}!`);
    }, "!coinflip — flips a coin (Heads/Tails)", { aliases: ["!flip", "!coin"] }
  );

    // !rules <discord/rpg/forums>
  register("!rules", async ({ message, rest }) => {
    const arg = rest.trim().toLowerCase();
    const links = {
      discord: "https://wiki.tppc.info/Discord%23Rules",
      rpg: "https://forums.tppc.info/forumdisplay.php?f=6",
      forums: "https://forums.tppc.info/showthread.php?t=42"
    };
  
    if (arg) {
      const url = links[arg];
      if (!url) {
        await message.reply(
          "Invalid argument. Usage: `!rules <discord/rpg/forums>` — returns the corresponding rules link."
        );
        return;
      }
      await message.reply(url);
    } else {
      // No argument provided — show all links
      const allLinks = Object.entries(links)
        .map(([key, url]) => `• **${key}**: ${url}`)
        .join("\n");
      await message.reply(`Here are all the rules links:\n${allLinks}`);
    }
  }, "!rules <discord/rpg/forums> — returns rules link(s)");
  
  // !boxorganizer
  register("!boxorganizer", async ({ message }) => {
    await message.reply("https://coldsp33d.github.io/box_organizer");
  }, "!boxorganizer — returns the organizer page link", { aliases: ["!organizer"]});

    // !tools
  register("!tools", async ({ message }) => {
    await message.reply("https://wiki.tppc.info/TPPC_Tools_and_Calculators");
  }, "!tools — returns a wiki link to several helpful TPPC tools, calculators and other utilties.",
  { aliases: ["!calculators", "!organizers"] });
    
  // !glossary <key> — quick definition lookup
  register("!glossary", async ({ message, rest }) => {
    const keyRaw = rest.trim();
    if (!keyRaw) return; // user didn't provide a key; show nothing (per your request)

    const key = keyRaw.toLowerCase();

    const def = glossary[key];
    if (!def) return; // key doesn't exist; show nothing (per your request)

    await message.reply(`**${key}** — ${def}`);
  }, "!glossary <key> — looks up a TPPC term (example: !glossary ul)", { aliases: ["!g"] });

  /* ------------------------------ Public API ----------------------------- */

  return {
    get: (name) => registry.get(name.toLowerCase())?.handler,
    list: () => [...registry.keys()].sort()
  };
}
