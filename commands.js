/**
 * commands.js
 *
 * Defines the bot’s command registry with categories.
 *
 * Flow:
 *   bot.js parses a message into { cmd, rest } and calls:
 *     registry.get(cmd)?.({ message, cmd, rest })
 *
 * Notes:
 *   - Unknown commands are ignored.
 *   - Admin-only commands: pass { admin: true } and enforce permission in handler.
 *   - !help is autogenerated and groups commands by category.
 */

import fs from "node:fs";
import path from "node:path";
import { createFaqService } from "./faq.js";
import { createWikiService } from "./wiki.js";
import { registerCalculator } from "./calculator.js";
import { registerContests } from "./contests.js";
import { registerTrades } from "./trades.js";
import { registerRarity, registerLevel4Rarity } from "./rarity.js";
import { startExplodingVoltorbs, passVoltorb } from "./games/explodingVoltorbs.js";

/* ---------------------- Helpers ---------------------- */

function randIntInclusive(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

function targetUserId(message) {
  const first = message.mentions?.users?.first?.();
  return first?.id ?? message.author.id;
}

function mention(id) {
  return `<@${id}>`;
}

function canReload(message) {
  if (!message.member) return false;
  return (
    message.member.permissions?.has("Administrator") ||
    message.member.permissions?.has("ManageGuild")
  );
}

const AWESOME_CHANNELS = {
  "329934860388925442": ["331114564966154240", "551243336187510784"]
};

const TRADING_GUILD_ALLOWLIST = (process.env.TRADING_GUILD_ALLOWLIST || "")
  .split(",").map(s => s.trim()).filter(Boolean);
const RARITY_GUILD_ALLOWLIST = (process.env.RARITY_GUILD_ALLOWLIST || "")
  .split(",").map(s => s.trim()).filter(Boolean);

const TRADING_ENABLED_ANYWHERE = TRADING_GUILD_ALLOWLIST.length > 0;
const RARITY_ENABLED_ANYWHERE = RARITY_GUILD_ALLOWLIST.length > 0;

function isAllowedChannel(message, allowlist) {
  if (!message.guild) return true; // DMs allowed
  const guildId = message.guild.id;
  const allowedChannels = allowlist[guildId];
  if (!Array.isArray(allowedChannels)) return true;
  return allowedChannels.includes(message.channel.id);
}

function loadNgsOnce() {
  const filePath = path.join(process.cwd(), "data", "ngs.json");
  const raw = fs.readFileSync(filePath, "utf8");
  const data = JSON.parse(raw);
  const ngs = Array.isArray(data) ? data : Array.isArray(data?.ngs) ? data.ngs : null;
  if (!ngs) throw new Error("data/ngs.json must be an array or { ngs: [...] }");
  return ngs.filter(x => typeof x === "string").map(x => x.trim()).filter(Boolean);
}

function loadGlossaryOnce() {
  const filePath = path.join(process.cwd(), "data", "glossary.json");
  const raw = fs.readFileSync(filePath, "utf8");
  const data = JSON.parse(raw);
  if (!data || typeof data !== "object" || Array.isArray(data)) {
    throw new Error("data/glossary.json must be an object map");
  }
  const map = {};
  for (const [k, v] of Object.entries(data)) {
    if (typeof k !== "string" || typeof v !== "string") continue;
    const kk = k.trim().toLowerCase();
    if (!kk) continue;
    map[kk] = v;
  }
  return map;
}

function parseSecondsToMs(raw) {
  const s = (raw ?? "").trim().toLowerCase();
  const m = /^(\d+)\s*s$/.exec(s);
  if (!m) return { error: "Delay must be specified in seconds, e.g. `2s` (1s–30s)." };
  const seconds = Number(m[1]);
  if (!Number.isInteger(seconds)) return { error: "Delay must be a whole number of seconds." };
  if (seconds < 1) return { error: "Delay must be at least 1 second." };
  if (seconds > 30) return { error: "Delay cannot exceed 30 seconds." };
  return { ms: seconds * 1000, seconds };
}

/* ---------------------- Registry ---------------------- */

export function buildCommandRegistry() {
  const registry = new Map();

  const faq = createFaqService();
  const wiki = createWikiService();
  registerCalculator(register);
  registerContests(register);
  if (TRADING_ENABLED_ANYWHERE) registerTrades(register);
  if (RARITY_ENABLED_ANYWHERE) registerRarity(register);
  registerLevel4Rarity(register);

  const ngs = loadNgsOnce();
  const glossary = loadGlossaryOnce();

  const MAX_ROLL_N = Number(process.env.MAX_ROLL_N ?? 50);
  const MAX_ROLL_M = Number(process.env.MAX_ROLL_M ?? 100000);

  function register(name, handler, help = "", opts = {}) {
    const entry = {
      handler,
      help,
      admin: Boolean(opts.admin),
      canonical: true,
      category: opts.category || "Uncategorized",
    };
    registry.set(name.toLowerCase(), entry);
    if (Array.isArray(opts.aliases)) {
      for (const alias of opts.aliases) {
        registry.set(alias.toLowerCase(), { ...entry, canonical: false });
      }
    }
  }

  /* ------------------ Contest commands ------------------ */

  register("!awesome", async ({ message }) => {
    if (!isAllowedChannel(message, AWESOME_CHANNELS)) return;
    const uid = targetUserId(message);
    const x = randIntInclusive(0, 101);
    await message.channel.send(`${mention(uid)} is ${x}% awesome!`);
  }, "!awesome — tells you how awesome someone is (0–101%)", { aliases: ["!a"], category: "Contest commands" });

  register("!coinflip", async ({ message }) => {
    const uid = targetUserId(message);
    const result = Math.random() < 0.5 ? "Heads" : "Tails";
    await message.channel.send(`${mention(uid)} ${result}!`);
  }, "!coinflip — flips a coin (Heads/Tails)", { aliases: ["!flip", "!coin"], category: "Contest commands" });

  register("!contest", async ({ message, rest }) => {
    const parts = rest.trim().split(/\s+/).filter(Boolean);
    if (parts[0] !== "exploding_voltorbs") return;
    const rangeArg = parts[1];
    startExplodingVoltorbs(message, rangeArg);
  }, "!contest exploding_voltorbs [min-max] — starts an exploding Voltorb game", { category: "Contest commands" });

  register("!conteststart", async ({ message, rest }) => {
    // Reaction contest starter placeholder
  }, "!conteststart <time> — starts a reaction contest", { category: "Contest commands" });

  register("!pass", async ({ message }) => passVoltorb(message), "!pass @user — pass the Voltorb (only during an active game)", { category: "Contest commands" });

  register("!rig", async ({ message }) => {
    const uid = targetUserId(message);
    await message.channel.send(`${mention(uid)} has now been blessed by rngesus.`);
  }, "!rig — bless someone with RNG", { category: "Contest commands" });

  /* ------------------ Tools ------------------ */

  register("!boxorganizer", async ({ message }) => {
    await message.reply("https://coldsp33d.github.io/box_organizer");
  }, "!boxorganizer — returns the organizer page link", { aliases: ["!organizer"], category: "Tools" });

  register("!calc", async ({ message, rest }) => {
    // Calculator logic placeholder
  }, "!calc — useful calculator functions for summing or converting levels or exp", { category: "Tools" });

  register("!tools", async ({ message }) => {
    await message.reply("https://wiki.tppc.info/TPPC_Tools_and_Calculators");
  }, "!tools — returns a wiki link to several helpful TPPC tools, calculators and other utilities", { aliases: ["!calculators", "!organizers"], category: "Tools" });

  /* ------------------ Helpful commands ------------------ */

  register("!faq", async ({ message, rest }) => {
    const qRaw = rest.trim();
    if (!qRaw) {
      await message.reply("Please ask a specific question, like: `!faq how do I goldenize?`\nYou can also browse FAQs here: https://forums.tppc.info/showthread.php?p=11516674#post11516674");
      return;
    }
    const out = faq.matchAndRender({ message, questionRaw: qRaw });
    if (!out) return;
    await message.reply(out);
  }, "!faq <question> — asks the FAQ bot", { category: "Helpful commands" });

  register("!glossary", async ({ message, rest }) => {
    const keyRaw = rest.trim();
    if (!keyRaw) return;
    const key = keyRaw.toLowerCase();
    const def = glossary[key];
    if (!def) return;
    await message.reply(`**${key}** — ${def}`);
  }, "!glossary <key> — looks up a TPPC term", { aliases: ["!g"], category: "Helpful commands" });

  register("!help", async ({ message }) => {
    const grouped = {};
    for (const { help, admin, canonical, category } of registry.values()) {
      if (!canonical || !help || admin) continue;
      if (!grouped[category]) grouped[category] = [];
      grouped[category].push(help);
    }
    const lines = Object.entries(grouped)
      .map(([cat, cmds]) => `**${cat}**\n• ${cmds.sort().join("\n• ")}`)
      .join("\n\n");
    if (!lines) return;
    await message.reply(`**Available commands:**\n${lines}`);
  }, "!help — shows this help message", { aliases: ["!helpme"], category: "Helpful commands" });

  register("!l4", async ({ message, rest }) => {
    // Level 4 rarity placeholder
  }, "!l4 <pokemon> — shows level 4 rarity statistics", { category: "Helpful commands" });

  register("!ng", async ({ message }) => {
    const maxShow = 5;
    const shown = ngs.slice(0, maxShow);
    const extra = ngs.length - shown.length;
    const body = shown.map(x => `• ${x}`).join("\n") + (extra > 0 ? `\n…and ${extra} more.` : "");
    await message.reply(`**Current NGs:**\n${body}`);
  }, "!ng — shows the current NG list", { aliases: ["!ngs"], category: "Helpful commands" });

  register("!rules", async ({ message, rest }) => {
    const arg = rest.trim().toLowerCase();
    const links = {
      discord: "https://wiki.tppc.info/Discord%23Rules",
      rpg: "https://forums.tppc.info/forumdisplay.php?f=6",
      forums: "https://forums.tppc.info/showthread.php?t=42"
    };
    if (arg) {
      const url = links[arg];
      if (!url) return await message.reply("Invalid argument. Usage: `!rules <discord/rpg/forums>`");
      await message.reply(url);
    } else {
      const allLinks = Object.entries(links).map(([k, u]) => `• **${k}**: ${u}`).join("\n");
      await message.reply(`Here are all the rules links:\n${allLinks}`);
    }
  }, "!rules <discord/rpg/forums> — returns rules link(s)", { category: "Helpful commands" });

  register("!wiki", async ({ message, rest }) => {
    const q = rest.trim();
    if (!q) return;
    const results = wiki.search(q);
    if (!results.length) return;
    const lines = results.map(r => `• [${r.title}](${r.url})`);
    await message.reply(lines.join("\n"));
  }, "!wiki <term> — links matching TPPC wiki pages", { aliases: ["!w"], category: "Helpful commands" });

  /* ------------------ Commands TBC ------------------ */

  register("?choose", async ({ message, rest }) => {
    const options = rest.trim().split(/\s+/).filter(Boolean);
    if (!options.length) return await message.channel.send("Usage: `!choose option1 option2 ...`");
    const pick = options[randIntInclusive(0, options.length - 1)];
    await message.channel.send(pick);
  }, "?choose a b c — randomly chooses one option", { category: "Commands TBC" });

  register("?elim", async ({ message, rest }) => {
    if (!message.guild) return;
    const parts = rest.trim().split(/\s+/).filter(Boolean);
    if (parts.length < 3) return await message.reply("Usage: `?elim <seconds>s <item1> <item2> [...]`");
    const parsed = parseSecondsToMs(parts[0]);
    if (parsed.error) return await message.reply(parsed.error);
    let remaining = parts.slice(1);
    if (remaining.length < 2) return await message.reply("You need at least 2 items to run an elimination.");
    await message.channel.send(`Setting up elimination with ${parsed.seconds}s between rounds... are you ready?`);
    const runRound = async () => {
      if (!message.channel) return;
      if (remaining.length === 1) { await message.channel.send(`${remaining[0]} wins!`); return; }
      const idx = Math.floor(Math.random() * remaining.length);
      const eliminated = remaining.splice(idx, 1)[0];
      await message.channel.send(`${eliminated} has been eliminated! Remaining: ${remaining.join(", ")}`);
      setTimeout(runRound, parsed.ms);
    };
    setTimeout(runRound, parsed.ms);
  }, "?elim <1–30s> <items...> — randomly eliminates one item per round", { category: "Commands TBC" });

  register("?roll", async ({ message, rest }) => {
    const m = /^(\d+)d(\d+)$/.exec(rest.trim());
    if (!m) return await message.channel.send("Invalid format. Please use a format like `1d100`");
    const n = Number(m[1]), sides = Number(m[2]);
    if (!Number.isInteger(n) || !Number.isInteger(sides) || n < 1 || sides < 0) return await message.channel.send("Invalid format. Please use a format like `1d100`");
    if (n > MAX_ROLL_N) return await message.channel.send(`Too many rolls. Max is ${MAX_ROLL_N}.`);
    if (sides > MAX_ROLL_M) return await message.channel.send(`Range too large. Max m is ${MAX_ROLL_M}.`);
    const uid = targetUserId(message);
    const rolls = Array.from({ length: n }, () => randIntInclusive(0, sides));
    await message.channel.send(`${mention(uid)} ${rolls.join(", ")}`);
  }, "?roll NdM — rolls N numbers from 0..M (example: !roll 1d100)", { category: "Commands TBC" });

  /* ------------------ Public API ------------------ */

  return {
    get: (name) => registry.get(name.toLowerCase())?.handler,
    list: () => [...registry.keys()].sort()
  };
}
