/**
 * commands.js
 *
 * Defines the bot’s command registry.
 *
 * Flow:
 *   bot.js parses a message into { cmd, rest } and calls:
 *     registry.get(cmd)?.({ message, cmd, rest })
 *
 * Adding a new command:
 *   1) Register it:
 *        register("!mycmd", async ({ message, rest }) => { ... }, "!mycmd — help text");
 *   2) Parse `rest` (trim / split on /\s+/) and validate inputs.
 *   3) Reply with `message.reply(...)` or `message.channel.send(...)`.
 *
 * Notes:
 *   - Unknown commands are ignored.
 *   - Admin-only commands: pass { admin: true } and enforce permission in handler.
 *   - `!help` is autogenerated from registry help strings and hides admin commands.
 */

import fs from "node:fs";
import path from "node:path";
import { createFaqService } from "./faq.js";
import { createWikiService } from "./wiki.js";
import { registerCalculator } from "./calculator.js";

// Small helpers used by multiple commands
function randIntInclusive(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

function targetUserId(message) {
  // If someone is mentioned, use the first mention; else author.
  const first = message.mentions?.users?.first?.();
  return first?.id ?? message.author.id;
}

function mention(id) {
  return `<@${id}>`;
}

function canReload(message) {
  if (!message.member) return false;
  return (
    message.member.permissions?.has("Administrator") ||
    message.member.permissions?.has("ManageGuild")
  );
}

// Load NG list ONCE (do not reload per command)
function loadNgsOnce() {
  const filePath = path.join(process.cwd(), "data", "ngs.json");
  const raw = fs.readFileSync(filePath, "utf8");
  const data = JSON.parse(raw);

  // Allow either ["A","B"] or {"ngs":["A","B"]}
  const ngs = Array.isArray(data) ? data : Array.isArray(data?.ngs) ? data.ngs : null;
  if (!ngs) throw new Error("data/ngs.json must be an array of strings, or { ngs: [...] }");

  return ngs
    .filter((x) => typeof x === "string")
    .map((x) => x.trim())
    .filter(Boolean);
}

export function buildCommandRegistry() {
  const registry = new Map();

  // Services (FAQ engine etc.)
  const faq = createFaqService();
  const wiki = createWikiService();
  registerCalculator(register);

  // Load NGs once at startup
  const ngs = loadNgsOnce();

  // Config
  const MAX_ROLL_N = Number(process.env.MAX_ROLL_N ?? 50);
  const MAX_ROLL_M = Number(process.env.MAX_ROLL_M ?? 100000);

  // Helper to register commands
  function register(name, handler, help = "", opts = {}) {
    const entry = {
      handler,
      help,
      admin: Boolean(opts.admin),
      canonical: true
    };

    registry.set(name.toLowerCase(), entry);

    // Register aliases (if any)
    if (Array.isArray(opts.aliases)) {
      for (const alias of opts.aliases) {
        registry.set(alias.toLowerCase(), {
          ...entry,
          canonical: false
        });
      }
    }
  }

  /* ------------------------------ Commands ------------------------------ */

  // ==========================================================================
  // ====== CURRENTLY COMMENTED OUT SINCE FLAREON STILL HANDLES THESE ====== //
  // ==========================================================================
  // register("!roll", async ({ message, rest }) => {
  //   const arg = rest.trim();
  //   const m = /^(\d+)d(\d+)$/.exec(arg);
  //   if (!m) {
  //     await message.channel.send("Invalid format. Please use a format like `1d100`");
  //     return;
  //   }

  //   const n = Number(m[1]);
  //   const sides = Number(m[2]);

  //   if (!Number.isInteger(n) || !Number.isInteger(sides) || n < 1 || sides < 0) {
  //     await message.channel.send("Invalid format. Please use a format like `1d100`");
  //     return;
  //   }

  //   if (n > MAX_ROLL_N) {
  //     await message.channel.send(`Too many rolls. Max is ${MAX_ROLL_N}.`);
  //     return;
  //   }
  //   if (sides > MAX_ROLL_M) {
  //     await message.channel.send(`Range too large. Max m is ${MAX_ROLL_M}.`);
  //     return;
  //   }

  //   const uid = targetUserId(message);
  //   const rolls = Array.from({ length: n }, () => randIntInclusive(0, sides));
  //   await message.channel.send(`${mention(uid)} ${rolls.join(", ")}`);
  // }, "!roll NdM — rolls N numbers from 0..M (example: !roll 1d100)");

  // register("!choose", async ({ message, rest }) => {
  //   const options = rest.trim().split(/\s+/).filter(Boolean);
  //   if (options.length < 1) {
  //     await message.channel.send("Usage: `!choose option1 option2 ...`");
  //     return;
  //   }
  //   const pick = options[randIntInclusive(0, options.length - 1)];
  //   await message.channel.send(pick);
  // }, "!choose a b c — randomly chooses one option");

  register("!awesome", async ({ message }) => {
    const uid = targetUserId(message);
    const x = randIntInclusive(0, 101);
    await message.channel.send(`${mention(uid)} is ${x}% awesome!`);
  }, "!awesome — tells you how awesome someone is (0–101%)");

  register("!faq", async ({ message, rest }) => {
    const qRaw = rest.trim();
    if (!qRaw) return; // no output if no question
    const out = faq.matchAndRender({ message, questionRaw: qRaw });
    if (!out) return; // no output if no confident match
    await message.reply(out);
  }, "!faq <question> — asks the FAQ bot");

  register(
    "!faqreload",
    async ({ message }) => {
      if (!canReload(message)) {
        await message.reply(
          "Nope — you don’t have permission to run that. (Admin/Manage Server only)"
        );
        return;
      }

      try {
        const info = faq.reload();
        await message.reply(
          `Reloaded faq.json ✅ (${info.count} entries${
            info.version ? `, v${info.version}` : ""
          })`
        );
      } catch (e) {
        console.error("faq reload failed:", e);
        await message.reply("Reload failed ❌ (check console + faq.json formatting)");
      }
    },
    "!faqreload — reloads faq.json",
    { admin: true }
  );

  register("!help", async ({ message }) => {
    const isAdmin =
      message.member?.permissions?.has("Administrator") ||
      message.member?.permissions?.has("ManageGuild");

    const lines = [];

    for (const { help, admin, canonical } of registry.values()) {
      if (!canonical) continue; // hide aliases
      if (!help) continue;
      if (admin) continue; // hide admin commands
      lines.push(help);
    }

    if (lines.length === 0) return;

    await message.reply(
      "**Available commands:**\n" +
      lines.sort().map(l => `• ${l}`).join("\n")
    );
  }, "!help — shows this help message");

  // Local-title-based wiki lookup (Cloudflare-proof)
  register("!wiki", async ({ message, rest }) => {
    const q = rest.trim();
    if (!q) return; // no output

    const results = wiki.search(q);
    if (results.length === 0) return; // no output if no match

    const lines = results.map(r => `• [${r.title}](${r.url})`);
    await message.reply(lines.join("\n"));
  }, "!wiki <term> — links matching TPPC wiki pages", { aliases: ["!w"] });

  // !ng — read from data/ngs.json (loaded once)
  register(
    "!ng",
    async ({ message }) => {
      if (ngs.length === 0) return;

      const maxShow = 5;
      const shown = ngs.slice(0, maxShow);
      const extra = ngs.length - shown.length;

      const body =
        shown.map(x => `• ${x}`).join("\n") +
        (extra > 0 ? `\n…and ${extra} more.` : "");

      await message.reply(`**Current NGs:**\n${body}`);
    },
    "!ng — shows the current NG list",
    { aliases: ["!ngs"] }
  );

  // !rig — bless a user
  register("!rig", async ({ message }) => {
    const uid = targetUserId(message);
    await message.channel.send(`${mention(uid)} has now been blessed by rnjesus.`);
    }, "!rig — bless someone with RNG"
  );

  // !coinflip — heads/tails
  register("!coinflip", async ({ message }) => {
    const uid = targetUserId(message);
    const result = Math.random() < 0.5 ? "Heads" : "Tails";
    await message.channel.send(`${mention(uid)} ${result}!`);
    }, "!coinflip — flips a coin (Heads/Tails)", { aliases: ["!flip", "!coin"] }
  );

  /* ------------------------------ Public API ----------------------------- */

  return {
    get: (name) => registry.get(name.toLowerCase())?.handler,
    list: () => [...registry.keys()].sort()
  };
}
